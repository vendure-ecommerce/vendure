import { PluginFunction } from '@graphql-codegen/plugin-helpers';
import { buildScalars } from '@graphql-codegen/visitor-plugin-common';
import {
    FieldDefinitionNode,
    GraphQLFieldMap,
    GraphQLNamedType,
    GraphQLObjectType,
    GraphQLSchema,
    GraphQLType,
    GraphQLUnionType,
    InterfaceTypeDefinitionNode,
    isNamedType,
    isObjectType,
    isTypeDefinitionNode,
    isUnionType,
    NonNullTypeNode,
    ObjectTypeDefinitionNode,
    parse,
    printSchema,
    UnionTypeDefinitionNode,
    visit,
    Visitor,
    ListTypeNode,
} from 'graphql';

// This plugin generates classes for all GraphQL types which implement the `ErrorResult` interface.
// This means that when returning an error result from a GraphQL operation, you can use one of
// the generated classes rather than constructing the object by hand.
// It also generates type resolvers to be used by Apollo Server to discriminate between
// members of returned union types.

export const ERROR_INTERFACE_NAME = 'ErrorResult';
const empty = () => '';

const errorsVisitor: Visitor<any> = {
    NonNullType(node: NonNullTypeNode): string | ListTypeNode {
        return node.type.kind === 'NamedType'
            ? node.type.name.value
            : node.type.kind === 'ListType'
            ? node.type
            : '';
    },
    FieldDefinition(node: FieldDefinitionNode): string {
        const scalarType = node.type.kind === 'ListType' ? node.type.type : node.type;
        const listPart = node.type.kind === 'ListType' ? `[]` : ``;
        return `  ${node.name.value}: Scalars['${scalarType}']${listPart}`;
    },
    ScalarTypeDefinition: empty,
    InputObjectTypeDefinition: empty,
    EnumTypeDefinition: empty,
    UnionTypeDefinition: empty,
    InterfaceTypeDefinition(node: InterfaceTypeDefinitionNode) {
        if (node.name.value !== ERROR_INTERFACE_NAME) {
            return '';
        }
        return [
            `export class ${ERROR_INTERFACE_NAME} {`,
            `  readonly __typename: string;`,
            `  readonly errorCode: string;`,
            ...node.fields.filter(f => !(f as any).includes('errorCode:')).map(f => `${f};`),
            `}`,
        ].join('\n');
    },

    ObjectTypeDefinition(
        node: ObjectTypeDefinitionNode,
        key: number | string | undefined,
        parent: any,
    ): string {
        if (!inheritsFromErrorResult(node)) {
            return '';
        }
        const originalNode = parent[key] as ObjectTypeDefinitionNode;

        return [
            `export class ${node.name.value} extends ${ERROR_INTERFACE_NAME} {`,
            `  readonly __typename = '${node.name.value}';`,
            // We cast this to "any" otherwise we need to specify it as type "ErrorCode",
            // which means shared ErrorResult classes e.g. OrderStateTransitionError
            // will not be compatible between the admin and shop variations.
            `  readonly errorCode = '${camelToUpperSnakeCase(node.name.value)}' as any;`,
            `  readonly message = '${camelToUpperSnakeCase(node.name.value)}';`,
            `  constructor(`,
            ...node.fields
                .filter(f => !(f as any).includes('errorCode:') && !(f as any).includes('message:'))
                .map(f => `    public ${f},`),
            `  ) {`,
            `    super();`,
            `  }`,
            `}`,
        ].join('\n');
    },
};

export const plugin: PluginFunction<any> = (schema, documents, config, info) => {
    const printedSchema = printSchema(schema); // Returns a string representation of the schema
    const astNode = parse(printedSchema); // Transforms the string into ASTNode
    const result = visit(astNode, { leave: errorsVisitor });
    const defs = result.definitions
        .filter(d => !!d)
        // Ensure the ErrorResult base class is first
        .sort((a, b) => (a.includes('class ErrorResult') ? -1 : 1));
    return {
        content: [
            `/** This file was generated by the graphql-errors-plugin, which is part of the "codegen" npm script. */`,
            generateScalars(schema, config),
            ...defs,
            defs.length ? generateIsErrorFunction(schema) : '',
            generateTypeResolvers(schema),
        ].join('\n\n'),
    };
};

function generateScalars(schema: GraphQLSchema, config: any): string {
    const scalarMap = buildScalars(schema, config.scalars);
    const allScalars = Object.keys(scalarMap)
        .map(scalarName => {
            const scalarValue = scalarMap[scalarName].type;
            const scalarType = schema.getType(scalarName);

            return `  ${scalarName}: ${scalarValue};`;
        })
        .join('\n');
    return `export type Scalars = {\n${allScalars}\n};`;
}

function generateErrorClassSource(node: ObjectTypeDefinitionNode) {
    let source = `export class ${node.name.value} {`;
    for (const field of node.fields) {
        source += `  ${1}`;
    }
}

function generateIsErrorFunction(schema: GraphQLSchema) {
    const errorNodes = Object.values(schema.getTypeMap())
        .map(type => type.astNode)
        .filter(isObjectTypeDefinition)
        .filter(node => inheritsFromErrorResult(node));
    return `
const errorTypeNames = new Set([${errorNodes.map(n => `'${n.name.value}'`).join(', ')}]);
function isGraphQLError(input: any): input is import('@vendure/common/lib/generated-types').${ERROR_INTERFACE_NAME} {
  return input instanceof ${ERROR_INTERFACE_NAME} || errorTypeNames.has(input.__typename);
}`;
}

function generateTypeResolvers(schema: GraphQLSchema) {
    const mutations = getOperationsThatReturnErrorUnions(schema, schema.getMutationType().getFields());
    const queries = getOperationsThatReturnErrorUnions(schema, schema.getQueryType().getFields());
    const operations = [...mutations, ...queries];
    const varName = isAdminApi(schema)
        ? `adminErrorOperationTypeResolvers`
        : `shopErrorOperationTypeResolvers`;
    const result = [`export const ${varName} = {`];
    const typesHandled = new Set<string>();
    for (const operation of operations) {
        const returnType = unwrapType(operation.type) as GraphQLUnionType;
        if (!typesHandled.has(returnType.name)) {
            typesHandled.add(returnType.name);
            const nonErrorResult = returnType.getTypes().find(t => !inheritsFromErrorResult(t));
            result.push(
                `  ${returnType.name}: {`,
                `    __resolveType(value: any) {`,
                // tslint:disable-next-line:no-non-null-assertion
                `      return isGraphQLError(value) ? (value as any).__typename : '${nonErrorResult!.name}';`,
                `    },`,
                `  },`,
            );
        }
    }
    result.push(`};`);
    return result.join('\n');
}

function getOperationsThatReturnErrorUnions(schema: GraphQLSchema, fields: GraphQLFieldMap<any, any>) {
    return Object.values(fields).filter(operation => {
        const innerType = unwrapType(operation.type);
        if (innerType.astNode?.kind === 'UnionTypeDefinition') {
            return isUnionOfResultAndErrors(schema, innerType.astNode);
        }
        return false;
    });
}

function isUnionOfResultAndErrors(schema: GraphQLSchema, node: UnionTypeDefinitionNode) {
    const errorResultTypes = node.types.filter(namedType => {
        const type = schema.getType(namedType.name.value);
        if (isObjectType(type)) {
            if (inheritsFromErrorResult(type)) {
                return true;
            }
        }
        return false;
    });
    return (errorResultTypes.length = node.types.length - 1);
}

function isObjectTypeDefinition(node: any): node is ObjectTypeDefinitionNode {
    return node && isTypeDefinitionNode(node) && node.kind === 'ObjectTypeDefinition';
}

function inheritsFromErrorResult(node: ObjectTypeDefinitionNode | GraphQLObjectType): boolean {
    const interfaceNames = isObjectType(node)
        ? node.getInterfaces().map(i => i.name)
        : node.interfaces.map(i => i.name.value);
    return interfaceNames.includes(ERROR_INTERFACE_NAME);
}

/**
 * Unwraps the inner type from a higher-order type, e.g. [Address!]! => Address
 */
function unwrapType(type: GraphQLType): GraphQLNamedType {
    if (isNamedType(type)) {
        return type;
    }
    let innerType = type;
    while (!isNamedType(innerType)) {
        innerType = innerType.ofType;
    }
    return innerType;
}

function isAdminApi(schema: GraphQLSchema): boolean {
    return !!schema.getType('UpdateGlobalSettingsInput');
}

function camelToUpperSnakeCase(input: string): string {
    return input.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
}
