---
title: 'Building a CMS Integration Plugin'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A CMS integration plugin allows you to automatically synchronize your Vendure product catalog with an external Content Management System.

This enables you to maintain a unified content strategy across your e-commerce platform and marketing channels.

This guide demonstrates how to build a production-ready CMS integration plugin. The principles covered here are desinged to be CMS-agnostic.

This guide will walk through a complete implementation that automatically syncs products, variants, and collections whenever changes occur in Vendure.

## Working Example Repository

:::info
The complete source code for the plugin described in this guide can be found in the [cms-integration-plugin example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/cms-integration-plugin).
:::

## Prerequisites

- Node.js 20+ with npm package manager
- An existing Vendure project created with the [Vendure create command](/guides/getting-started/installation/)
- An access key to a CMS platform that provides an API

## Core Concepts

This [plugin](/guides/developer-guide/plugins/) leverages several key Vendure concepts:

- **[EventBus](/guides/developer-guide/events/)**: Provides real-time notifications when entities are created, updated, or deleted.
- **[Job Queues](/guides/developer-guide/worker-job-queue/)**: Ensures that synchronization tasks are performed reliably and asynchronously, with retries on failure.
- **[Plugin API](/guides/developer-guide/plugins/)**: The foundation for extending Vendure with custom capabilities.

## Plugin Structure and Types

First, let's use the Vendure CLI to scaffold the basic plugin structure:

```bash
npx vendure add -p CmsPlugin
```

This command will create the basic plugin structure. Next, we'll generate the required services:

```bash
# Generate the main sync service
npx vendure add -s CmsSyncService --selected-plugin CmsPlugin

# Generate the CMS-specific service (replace with your CMS, e.g., StoryblokService)
npx vendure add -s cmsSpecifcService --selected-plugin CmsPlugin
```

Now we start by defining the main [plugin](/guides/developer-guide/plugins/) class, its [services](/guides/developer-guide/the-service-layer/), and the configuration types.

### Plugin Definition

The `CmsPlugin` class registers the necessary [services](/guides/developer-guide/the-service-layer/) (`CmsSyncService`, `StoryblokService`) and sets up any Admin API extensions.

```ts title="src/plugins/cms/cms.plugin.ts"
import { VendurePlugin, PluginCommonModule } from '@vendure/core';
import { CmsSyncService } from './services/cms-sync.service';
import { StoryblokService } from './services/storyblok.service';
// ...

@VendurePlugin({
    imports: [PluginCommonModule],
    providers: [
        { provide: CMS_PLUGIN_OPTIONS, useFactory: () => CmsPlugin.options },
        CmsSyncService,
        StoryblokService, // The service for the specific CMS platform
    ],
    // ...
})
export class CmsPlugin {
    static options: PluginInitOptions;

    static init(options: PluginInitOptions): Type<CmsPlugin> {
        this.options = options;
        return CmsPlugin;
    }
}
```

### Configuration Types

The plugin's configuration options are defined in a `types.ts` file.
Create this file in your plugin directory to define the interfaces. These options will be passed to the plugin from your `vendure-config.ts`.

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    cmsApiKey?: string;
    storyblokSpaceId?: string; // Storyblok-specific option
    retryAttempts?: number;
    retryDelay?: number;
}

export interface SyncJobData {
    entityType: 'Product' | 'ProductVariant' | 'Collection';
    entityId: ID;
    operationType: 'create' | 'update' | 'delete';
    timestamp: string;
    retryCount: number;
}
```

## Event-Driven Synchronization

The plugin uses Vendure's [EventBus](/guides/developer-guide/events/) to capture changes in real-time.

In the [onModuleInit](/guides/developer-guide/events/#subscribing-to-events) lifecycle hook, we create job queues and subscribe to entity events.

### Creating Job Queues and Subscribing to Events

You can also scaffold job queue handlers using the CLI:

```bash
npx vendure add -j CmsProductSync --selected-plugin CmsPlugin
```

When an event is detected, we add a [new job to the appropriate queue](/guides/developer-guide/worker-job-queue/).

```ts title="src/plugins/cms/cms.plugin.ts"
export class CmsPlugin implements OnModuleInit {
    private productSyncQueue: JobQueue<SyncJobData>;
    // ... other queues

    constructor(
        private eventBus: EventBus,
        private jobQueueService: JobQueueService,
        private cmsSyncService: CmsSyncService,
    ) {}

    async onModuleInit() {
        // Create a job queue for product synchronization
        this.productSyncQueue = await this.jobQueueService.createQueue({
            name: 'cms-product-sync',
            process: async job => {
                return this.cmsSyncService.syncProductToCms(job.data);
            },
        });

        // Listen for Product events
        this.eventBus.ofType(ProductEvent).subscribe(async event => {
            const syncData = this.extractSyncData(event);
            await this.productSyncQueue.add(syncData);
        });

        // Similar listeners for ProductVariantEvent and CollectionEvent...
    }
    // ...
}
```

## Implementing the Sync Logic

The sync logic is split into two services: a generic service to fetch data, and a specific service to communicate with the CMS.

### The Generic Sync Service

`CmsSyncService` acts as an intermediary. The job queue processor calls this service, which is responsible for fetching the complete entity data from the database. It then calls a mock `CmsService` to perform the actual sync.

:::tip
Separating the services to one that orchestrates the sync logic and a service that makes calls to the CMS allows for better testability and maintainability.
:::

```ts title="src/plugins/cms/services/cms-sync.service.ts"
@Injectable()
export class CmsSyncService {
    constructor(
        private connection: TransactionalConnection,
        private cmsService: CmsService, // Injected here
    ) {}

    async syncProductToCms(jobData: SyncJobData): Promise<any> {
        const { entityId, operationType } = jobData;
        const product = await this.connection.getRepository(Product).findOne({
            /* ... */
        });

        if (product) {
            // Add your own cms services here
            return this.cmsService.syncProduct({ product, operationType });
        }
    }
    // implement syncProductVariant, Collection and etc...
    // ...

    // this method is used to get the default language code for the default channel
    private async getDefaultLanguageCode(): Promise<LanguageCode> {
        const defaultChannel = await this.channelService.getDefaultChannel();
        return defaultChannel.defaultLanguageCode;
    }
}
```

### Platform specific setup

<Tabs>
<TabItem value="storyblok" label="Storyblok">

:::tip Working Example
The complete source code for this Storyblok integration can be found in the [cms-integration-plugin example repository](https://github.com/vendure-ecommerce/examples/tree/publish/examples/cms-integration-plugin).
:::

**Setting up Storyblok Space**

#### 1. Create a Storyblok Account and Space

1. Sign up at [storyblok.com](https://app.storyblok.com/#!/signup) if you don't have an account
2. Create a new Space (equivalent to a project in Storyblok)
3. Choose a suitable plan based on your needs

#### 2. Get Your API Credentials

1. Navigate to **Settings → Access Tokens** in your Storyblok space
2. Create a new **Management API Token** with write permissions
3. Note down your **Space ID** (found in Settings → General)

#### 3. Configure Environment Variables

Add these variables to your `.env` file:

```env
STORYBLOK_API_KEY=your_management_api_token
STORYBLOK_SPACE_ID=your_space_id
```

**The Storyblok Service**

`StoryblokService` contains all logic specific to the Storyblok API. Its responsibilities include data transformation, making authenticated API calls, handling rate-limiting, and ensuring the required content types exist on startup.

```ts title="src/plugins/cms/services/storyblok.service.ts"
@Injectable()
export class StoryblokService implements OnApplicationBootstrap {
    // Storyblok Management API base URL for all requests
    private readonly storyblokBaseUrl = 'https://mapi.storyblok.com/v1';
    private readonly componentsPath = 'components';
    private isInitialized = false;
    private lastApiCallTime = 0;
    // Rate limiting: max 5 calls per second to comply with Storyblok API limits
    private readonly rateLimitDelay = 200;

    // Injects plugin configuration containing Storyblok credentials
    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    // Called when application starts - ensures required content types exist in Storyblok
    async onApplicationBootstrap() {
        this.ensureStoryContentTypesExists();
    }

    // Main sync method that routes different operations to appropriate handlers
    async syncProduct({ product, operationType }) {
        switch (operationType) {
            case 'create':
                await this.createStoryFromProduct(product);
                break;
            case 'update':
                await this.updateStoryFromProduct(product);
                break;
            case 'delete':
                await this.deleteStoryFromProduct(product);
                break;
        }
    }

    // implement syncProductVariant, Collection and etc...
    // ...

    // Generic method for making authenticated requests to Storyblok's Management API
    private async makeStoryblokRequest({ method, endpoint, data }) {
        // Enforces rate limiting to avoid hitting API limits
        await this.enforceRateLimit();
        const url = `${this.storyblokBaseUrl}/spaces/${this.options.storyblokSpaceId}/${endpoint}`;

        // Waits for content types initialization before making requests
        if (!skipInitializationCheck) {
            let attempts = 0;
            while (!this.isInitialized && attempts < 100) {
                await new Promise(res => setTimeout(res, Math.min(10 + 1.03 ** attempts, 30000)));
                attempts++;
            }
        }

        // Makes authenticated request with proper headers
        const response = await fetch(url, {
            method,
            headers: {
                'Content-Type': 'application/json',
                Authorization: this.options.cmsApiKey, // Management API token
            },
            body: method === 'POST' || method === 'PUT' ? JSON.stringify(data) : undefined,
        });

        // Handles API errors by throwing descriptive error messages
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Storyblok API error: ${response.status} - ${errorText}`);
        }

        return method === 'DELETE' ? {} : await response.json();
    }

    // Ensures required content types (components) exist in Storyblok space
    private async ensureStoryContentTypesExists() {
        const contentCheck = await this.checkContentTypes();

        // Creates component schemas for products, variants, and collections
        if (!contentCheck.product) {
            await this.createContentType('product');
        }
        if (!contentCheck.variant) {
            await this.createContentType('product_variant');
        }
        if (!contentCheck.collection) {
            await this.createContentType('collection');
        }

        this.isInitialized = true;
    }

    // Rate limiting implementation to comply with Storyblok API limits
    private async enforceRateLimit(): Promise<void> {
        const now = Date.now();
        const timeSinceLastCall = now - this.lastApiCallTime;

        if (timeSinceLastCall < this.rateLimitDelay) {
            const waitTime = this.rateLimitDelay - timeSinceLastCall;
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }

        this.lastApiCallTime = Date.now();
    }
}
```

**Configuration**

Update your plugin configuration to include Storyblok options:

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    // ... existing options
    cmsApiKey?: string;
    storyblokSpaceId?: string;
}
```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  cmsApiKey: process.env.STORYBLOK_API_KEY,
  storyblokSpaceId: process.env.STORYBLOK_SPACE_ID,
}),
```

This setup provides a complete Storyblok CMS integration that automatically creates the necessary content types and syncs your Vendure catalog with structured content in Storyblok.

</TabItem>
<TabItem value="Sanity" title="Sanity">
**Sanity CMS Integration**

This tab provides a complete guide for integrating Vendure with Sanity CMS, including setting up a Sanity Studio and implementing the synchronization service.

**Setting up Sanity Studio**

#### 1. Create a new Studio with Sanity CLI

Initialize your Sanity project using the CLI. Replace `<project-id>` with your actual project ID:

```bash
npm create sanity@latest -- --project <project-id> --dataset production --template clean --typescript --output-path studio-vendure-plugin
cd studio-vendure-plugin
```

#### 2. Run Sanity Studio locally

Start the development server:

```bash
npm run dev
```

#### 3. Log in to the Studio

Open your browser to `http://localhost:3333` and log in using the same service (Google, GitHub, or email) that you used with the Sanity CLI.

**Defining Schema Types**

#### 1. Create Vendure-specific document types

Create the Vendure-specific schema files in your `schemaTypes` folder:

for example, here is a schema file for a Vendure product variant:

**vendureProductVariant.ts**

```ts
import { defineField, defineType } from 'sanity';

export const vendureProductVariant = defineType({
    name: 'vendureProductVariant',
    title: 'Vendure Product Variant',
    type: 'document',
    fields: [
        defineField({
            name: 'vendureId',
            type: 'number',
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'title',
            type: 'string',
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'slug',
            type: 'slug',
            options: { source: 'title' },
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'vendureProduct',
            type: 'reference',
            to: [{ type: 'vendureProduct' }],
        }),
        defineField({
            name: 'vendureCollecitons',
            type: 'array',
            of: [{ type: 'reference', to: [{ type: 'vendureCollection' }] }],
        }),
    ],
});
```

#### 2. Register the schema types

Update your `schemaTypes/index.ts` file:

```ts
import { vendureCollection } from './vendureCollection';
import { vendureProductType } from './vendureProductType';
import { vendureProductVariant } from './vendureProductVariant';

export const schemaTypes = [
    vendureProductVariant,
    // ...
];
```

**The Sanity Service**

#### Implementation

The `SanityService` contains all logic specific to the Sanity API. Unlike Storyblok, Sanity doesn't require content type creation as schemas are defined in the Studio.

```ts title="src/plugins/cms/services/sanity.service.ts"
@Injectable()
export class SanityService {
    // Constructs the Sanity API base URL using the project ID from configuration
    private get sanityBaseUrl(): string {
        // the options.sanityProjectId are defined in your vendure-config.ts file.
        return `https://${this.options.sanityProjectId}.api.sanity.io/v2025-09-01`;
    }

    // Injects the plugin configuration options containing Sanity credentials
    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    // Main sync method that routes different operations to appropriate handlers
    async syncProduct({ product, operationType }) {
        switch (operationType) {
            case 'create':
                await this.createDocumentFromProduct(product);
                break;
            case 'update':
                await this.updateDocumentFromProduct(product);
                break;
            case 'delete':
                await this.deleteDocumentFromProduct(product);
                break;
        }
    }

    // implement syncProductVariant, syncCollection...

    // Generic method for making authenticated requests to Sanity's API
    private async makeSanityRequest({ method, endpoint, data }) {
        const url = `${this.sanityBaseUrl}/${endpoint}`;

        // Makes authenticated request with proper headers
        const response = await fetch(url, {
            method,
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.options.sanityApiKey}`,
            },
            body: JSON.stringify(data),
        });

        // Handles API errors by throwing descriptive error messages
        if (!response.ok) {
            throw new Error(`Sanity API error: ${response.status}`);
        }

        return await response.json();
    }

    // Creates a new document in Sanity from a Vendure product
    private async createDocumentFromProduct(product, defaultLanguageCode: LanguageCode) {
        // Transforms Vendure product data to Sanity document format
        const data = this.transformProductData(product, defaultLanguageCode);
        // Uses Sanity's mutation API to create the document
        return this.makeSanityRequest({
            method: 'POST',
            endpoint: `data/mutate/${this.options.sanityDataset || 'production'}`,
            data: { mutations: [{ create: data }] },
        });
    }

    // Transforms Vendure product data into Sanity document structure
    private transformProductData(product, defaultLanguageCode: LanguageCode) {
        return {
            _type: 'vendureProduct', // Sanity document type
            vendureId: parseInt(product.id.toString()), // Original Vendure ID as number
            title: product.translations[defaultLanguageCode]?.name, // Product name from first translation
            slug: { current: product.translations[defaultLanguageCode]?.slug }, // Sanity slug format
            // Add variant references as needed
        };
    }
}
```

**Configuration**

Update your plugin configuration to include Sanity options:

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    // ... existing options
    sanityApiKey?: string;
    sanityProjectId?: string;
    sanityDataset?: string;
}
```

**Environment Variables**

Add these to your `.env` file:

```env
SANITY_API_KEY=your_sanity_api_key
SANITY_PROJECT_ID=your_project_id
SANITY_DATASET=production
```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  sanityApiKey: process.env.SANITY_API_KEY,
  sanityProjectId: process.env.SANITY_PROJECT_ID,
  sanityDataset: process.env.SANITY_DATASET,
}),
```

This setup provides a complete Sanity CMS integration that automatically syncs your Vendure catalog with structured content in Sanity Studio.

</TabItem>
<TabItem value="more-soon" label="More guides coming soon">
:::info
More guides coming soon :D
:::
</TabItem>
</Tabs>

## Admin UI Integration

To allow for manual synchronization, we can extend the Admin API with new mutations. Let's use the CLI to generate the API extensions:

```bash
# Generate API extensions for the CMS plugin
npx vendure add -a CmsSyncAdminResolver --selected-plugin CmsPlugin
```

### Extending the GraphQL API

```ts title="src/plugins/cms/api/api-extensions.ts"
export const adminApiExtensions = gql`
  extend type Mutation {
    syncProductToCms(productId: ID!): SyncResponse!
    syncCollectionToCms(collectionId: ID!): SyncResponse!
  }
  // ...
`;
```

### Implementing the Resolver

The resolver for these mutations re-uses the existing `CmsSyncService` to add a job to the queue.

```ts title="src/plugins/cms/api/cms-sync-admin.resolver.ts"
@Resolver()
export class CmsSyncAdminResolver {
    constructor(private cmsSyncService: CmsSyncService) {}

    @Mutation()
    @Allow(Permission.UpdateCatalog)
    async syncProductToCms(@Args() args: { productId: ID }): Promise<any> {
        const syncData = { entityId: args.productId, operationType: 'update' };
        return this.cmsSyncService.syncProductToCms(syncData);
    }
}
```

## Final Configuration

Finally, add the plugin to your `vendure-config.ts` file and provide the necessary options to connect to your Storyblok space.

```ts title="src/vendure-config.ts"
import { VendureConfig } from '@vendure/core';
import { CmsPlugin } from './plugins/cms/cms.plugin';

export const config: VendureConfig = {
    // ... other config
    plugins: [
        // ... other plugins
        CmsPlugin.init({
            cmsApiKey: process.env.CMS_API_KEY,
            cmsEndpointID: process.env.CMS_ENDPOINT_ID,
        }),
    ],
};
```

Your `.env` file should contain the corresponding values:

make sure you adapt this to your CMS provider

```env
CMS_API_KEY="your_cms_api_key"
CMS_ENDPOINT_ID="your_cms_endpoint_id"
```
