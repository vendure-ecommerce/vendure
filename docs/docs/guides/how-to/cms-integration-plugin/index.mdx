---
title: 'Building a CMS Integration Plugin'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A CMS integration plugin allows you to automatically synchronize your Vendure product catalog with an external Content Management System.

This enables you to maintain a unified content strategy across your e-commerce platform and marketing channels.

This guide demonstrates how to build a production-ready CMS integration plugin. The principles covered here are designed to be CMS-agnostic.

This guide will walk through a complete implementation that automatically syncs products, variants, and collections whenever changes occur in Vendure.

## Working Example Repository

:::info
This guide provides a high-level overview of building a CMS integration plugin. For complete implementations, refer to these working examples:

The complete source code for the plugin described in this guide can be found in the [cms-integration-plugin example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/cms-integration-plugin).

The code examples in this guide are simplified for educational purposes. The actual implementations contain additional features like error handling, retry logic, and performance optimizations.
:::

## Prerequisites

- Node.js 20+ with npm package manager
- An existing Vendure project created with the [Vendure create command](/guides/getting-started/installation/)
- An access key to a CMS platform that provides an API

## Core Concepts

This [plugin](/guides/developer-guide/plugins/) leverages several key Vendure concepts:

- **[EventBus](/guides/developer-guide/events/)**: Provides real-time notifications when entities are created, updated, or deleted.
- **[Job Queues](/guides/developer-guide/worker-job-queue/)**: Ensures that synchronization tasks are performed reliably and asynchronously, with retries on failure.
- **[Plugin API](/guides/developer-guide/plugins/)**: The foundation for extending Vendure with custom capabilities.

## How It Works

The CMS integration follows a simple event-driven flow:

```
Vendure Entity Change → EventBus → Job Queue → Sync Service → CMS API
    (Product/Variant/Collection)     (Async Processing)   (Transform & Send)
```

This ensures reliable, asynchronous synchronization with built-in retry capabilities.

## Plugin Structure and Types

First, let's use the Vendure CLI to scaffold the basic plugin structure:

```bash
npx vendure add -p CmsPlugin
```

This command will create the basic plugin structure. Next, we'll generate the required services:

```bash
# Generate the main sync service
npx vendure add -s CmsSyncService --selected-plugin CmsPlugin

# Generate the CMS-specific service (replace with your CMS, e.g., StoryblokService)
npx vendure add -s cmsSpecificService --selected-plugin CmsPlugin
```

Now we start by defining the main [plugin](/guides/developer-guide/plugins/) class, its [services](/guides/developer-guide/the-service-layer/), and the configuration types.

### Plugin Definition

The `CmsPlugin` class registers the necessary [services](/guides/developer-guide/the-service-layer/) (`CmsSyncService`, `StoryblokService`) and sets up any Admin API extensions.

```ts title="src/plugins/cms/cms.plugin.ts"
import { VendurePlugin, PluginCommonModule, Type, OnModuleInit } from '@vendure/core';
import { CmsSyncService } from './services/cms-sync.service';
import { StoryblokService } from './services/storyblok.service';
import { PluginInitOptions, CMS_PLUGIN_OPTIONS } from './types';
// ...

@VendurePlugin({
    imports: [PluginCommonModule],
    providers: [
        { provide: CMS_PLUGIN_OPTIONS, useFactory: () => CmsPlugin.options },
        CmsSyncService,
        StoryblokService, // The service for the specific CMS platform
    ],
    // ...
})
export class CmsPlugin {
    static options: PluginInitOptions;

    static init(options: PluginInitOptions): Type<CmsPlugin> {
        this.options = options;
        return CmsPlugin;
    }
}
```

### Configuration Types

The plugin's configuration options are defined in a `types.ts` file.
Create this file in your plugin directory to define the interfaces. These options will be passed to the plugin from your `vendure-config.ts`.

```ts title="src/plugins/cms/types.ts"
import { ID, InjectionToken } from '@vendure/core';

export interface PluginInitOptions {
    cmsApiKey?: string;
    storyblokSpaceId?: string; // Storyblok-specific option
    retryAttempts?: number;
    retryDelay?: number;
}

export interface SyncJobData {
    entityType: 'Product' | 'ProductVariant' | 'Collection';
    entityId: ID;
    operationType: 'create' | 'update' | 'delete';
    timestamp: string;
    retryCount: number;
}

export interface SyncResponse {
    success: boolean;
    message?: string;
    error?: string;
}

export const CMS_PLUGIN_OPTIONS = new InjectionToken<PluginInitOptions>('CMS_PLUGIN_OPTIONS');
```

## Event-Driven Synchronization

The plugin uses Vendure's [EventBus](/guides/developer-guide/events/) to capture changes in real-time.

In the [onModuleInit](/guides/developer-guide/events/#subscribing-to-events) lifecycle hook, we create job queues and subscribe to entity events.

### Creating Job Queues and Subscribing to Events

You can also scaffold job queue handlers using the CLI:

```bash
npx vendure add -j CmsProductSync --selected-plugin CmsPlugin
```

When an event is detected, we add a [new job to the appropriate queue](/guides/developer-guide/worker-job-queue/).

```ts title="src/plugins/cms/cms.plugin.ts"
export class CmsPlugin implements OnModuleInit {
    private productSyncQueue: JobQueue<SyncJobData>;
    // ... other queues

    constructor(
        private eventBus: EventBus,
        private jobQueueService: JobQueueService,
        private cmsSyncService: CmsSyncService,
    ) {}

    async onModuleInit() {
        // Create a job queue for product synchronization
        this.productSyncQueue = await this.jobQueueService.createQueue({
            name: 'cms-product-sync',
            process: async job => {
                return this.cmsSyncService.syncProductToCms(job.data);
            },
        });

        // Listen for Product events
        this.eventBus.ofType(ProductEvent).subscribe(async event => {
            const syncData = this.extractSyncData(event);
            await this.productSyncQueue.add(syncData);
        });

        // Similar listeners for ProductVariantEvent and CollectionEvent...
    }
    // ...
}
```

## Implementing the Sync Logic

The sync logic is split into two services: a generic service to fetch data, and a specific service to communicate with the CMS.

### The Generic Sync Service

`CmsSyncService` orchestrates the synchronization logic. It fetches complete entity data from the database, handles relationships (variants ↔ products ↔ collections), and delegates to the CMS-specific service.

:::tip
Separating orchestration logic from CMS-specific API calls allows for better testability and maintainability. The sync service handles Vendure-specific operations while CMS services focus on API communication.
:::

Key responsibilities include:

- Entity data fetching with proper relations
- Translation handling and validation
- Relationship resolution (finding collections for variants, etc.)
- Error handling and retry logic
- Bulk synchronization with parallel processing

```ts title="src/plugins/cms/services/cms-sync.service.ts"
@Injectable()
export class CmsSyncService {
    constructor(
        private connection: TransactionalConnection,
        private cmsService: CmsService, // Your CMS-specific service
        private channelService: ChannelService,
        // ... other services
    ) {}

    async syncProductToCms(jobData: SyncJobData): Promise<SyncResponse> {
        // Fetch product with relations
        const product = await this.connection.getRepository(Product).findOne({
            where: { id: jobData.entityId },
            relations: { translations: true },
        });

        const defaultLanguageCode = await this.getDefaultLanguageCode();

        // Delegate to CMS-specific service
        return this.cmsService.syncProduct({
            product,
            defaultLanguageCode,
            operationType: jobData.operationType,
        });
    }

    // Additional methods: syncVariantToCms, syncCollectionToCms,
    // findCollectionsForVariant, bulk sync operations, etc.
}
```

## Platform specific setup

<Tabs>
<TabItem value="storyblok" label="Storyblok">

:::tip Working Example
The complete, production-ready Storyblok implementation can be found in the [Storyblok integration example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/storyblok-cms-integration). It includes advanced features like rate limiting, content type management, and bulk operations.
:::

**Setting up Storyblok Space**

#### 1. Create a Storyblok Account and Space

1. Sign up at [storyblok.com](https://app.storyblok.com/#!/signup) if you don't have an account
2. Create a new Space (equivalent to a project in Storyblok)
3. Choose a suitable plan based on your needs

#### 2. Get Your API Credentials

1. Navigate to **Settings → Access Tokens** in your Storyblok space
2. Create a new **Management API Token** with write permissions
3. Note down your **Space ID** (found in Settings → General)

#### 3. Configure Environment Variables

Add these variables to your `.env` file:

```env
STORYBLOK_API_KEY=your_management_api_token
STORYBLOK_SPACE_ID=your_space_id
```

**The Storyblok Service**

`StoryblokService` handles all Storyblok-specific operations including API communication, content type management, and data transformation. Key features include:

- **Content Type Management**: Automatically creates Vendure-specific content types (components) in Storyblok
- **Rate Limiting**: Respects Storyblok's API limits (max 5 calls/second)
- **Story Management**: CRUD operations for stories representing products, variants, and collections
- **Relationship Handling**: Manages references between products, variants, and collections

### Basic Service Structure

The service follows Vendure's standard dependency injection pattern and implements [OnApplicationBootstrap](/reference/typescript-api/common/on-application-bootstrap) to ensure Storyblok is properly configured before handling sync operations.

```ts title="src/plugins/cms/services/storyblok.service.ts"
// Define component types as constants for consistency and maintainability
const COMPONENT_TYPE = {
    product: 'vendure_product',
    product_variant: 'vendure_product_variant',
    collection: 'vendure_collection',
};

@Injectable()
export class StoryblokService implements OnApplicationBootstrap {
    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    async onApplicationBootstrap() {
        // This lifecycle hook ensures Storyblok components (content types) are created
        // before any sync operations begin. This prevents API errors when trying to
        // create stories with non-existent component types.
        await this.ensureStoryContentTypesExists();
    }

    // Main entry point for product synchronization
    // The operationType determines which CRUD operation to perform
    async syncProduct({ product, defaultLanguageCode, operationType }) {
        switch (operationType) {
            case 'create':
                return this.createStoryFromProduct(product, defaultLanguageCode);
            case 'update':
                return this.updateStoryFromProduct(product, defaultLanguageCode);
            case 'delete':
                return this.deleteStoryFromProduct(product, defaultLanguageCode);
        }
    }
}
```

### Making API Requests

All Storyblok API communication is centralized through a single method that handles authentication, error handling, and response parsing. This approach ensures consistent behavior across all operations.

```ts
private async makeStoryblokRequest({ method, endpoint, data }) {
    // Construct the full API URL using the configured space ID
    const url = `https://mapi.storyblok.com/v1/spaces/${this.options.storyblokSpaceId}/${endpoint}`;

    const response = await fetch(url, {
        method,
        headers: {
            Authorization: this.options.storyblokApiKey,
            'Content-Type': 'application/json',
        },
        // Only include request body for POST/PUT operations
        body: data ? JSON.stringify(data) : undefined,
    });

    if (!response.ok) {
        // Provide clear error messages for debugging API issues
        throw new Error(`Storyblok API error: ${response.status}`);
    }
    return response.json();
}
```

### Data Transformation

Transformation methods convert Vendure entities into the format expected by Storyblok's API. The `content` object structure must match the component schema defined in Storyblok.

```ts
private async transformProductData(product, defaultLanguageCode, productSlug?) {
    // Extract the translation for the default language
    // Vendure stores translations in an array, so we need to find the correct one
    const translation = product.translations.find(
        t => t.languageCode === defaultLanguageCode
    );

    if (!translation) {
        return undefined; // Skip if no translation exists
    }

    // Find all variant story UUIDs for this product using relationship handling
    const variantStoryIds = await this.findVariantStoriesForProductUuids(
        product.id,
        defaultLanguageCode,
        productSlug,
    );

    return {
        story: {
            name: translation?.name, // Story name in Storyblok
            slug: translation?.slug,  // URL slug for the story
            content: {
                component: COMPONENT_TYPE.product, // Must match the component name in Storyblok
                vendureId: product.id.toString(),  // Store Vendure ID for reference
                variants: variantStoryIds, // Array of story UUIDs for product variants
            },
        },
        publish: 1, // Auto-publish the story (1 = published, 0 = draft)
    };
}
```

### Relationship Handling

One of the most important aspects of CMS integration is maintaining relationships between entities. Products have variants, variants belong to collections, and these relationships need to be reflected in the CMS. Storyblok uses story UUIDs to create references between content pieces.

#### Finding Related Entities

First, we need methods to query the Vendure database for related entities:

```ts
// Find all product variants for a given product ID from the database
private async findProductVariants(productId: string | number): Promise<ProductVariant[]> {
    try {
        return await this.connection.rawConnection
            .getRepository(ProductVariant)
            .find({
                where: { productId: productId as any },
                relations: ['translations'], // Include translations for slug generation
                order: { id: 'ASC' },
            });
    } catch (error) {
        Logger.error(`Failed to find variants for product ${productId}`, String(error));
        return [];
    }
}
```

#### Batch Story Lookups

For performance, we use batch lookups to find multiple stories at once:

```ts
// Batch lookup method for efficient story retrieval
private async findStoriesBySlugs(slugs: string[]): Promise<Map<string, any>> {
    const storyMap = new Map<string, any>();
    if (slugs.length === 0) return storyMap;

    try {
        // Storyblok supports comma-separated slugs for batch lookup
        const slugsParam = slugs.join(',');
        const response = await this.makeStoryblokRequest({
            method: 'GET',
            endpoint: `stories?by_slugs=${slugsParam}`,
        });

        if (response.stories) {
            for (const story of response.stories) {
                storyMap.set(story.slug, story);
            }
        }
    } catch (error) {
        Logger.error(`Failed to find stories by slugs: ${slugs.join(', ')}`, String(error));
    }

    return storyMap;
}
```

#### Building Relationships

Finally, we combine database queries with CMS lookups to build relationships:

```ts
// Find variant stories using batch lookup for efficiency
private async findVariantStoriesForProductUuids(
    productId: string | number,
    defaultLanguageCode: LanguageCode,
    productSlug?: string | null,
): Promise<string[]> {
    if (!productSlug) return [];

    // Get all variants for this product from Vendure database
    const variants = await this.findProductVariants(productId);
    
    // Generate slugs for all variants (convention: product-slug-variant-id)
    const variantSlugs = variants.map(
        (variant) => `${productSlug}-variant-${variant.id}`,
    );

    if (variantSlugs.length === 0) return [];

    // Batch lookup all variant stories and extract UUIDs
    const storiesMap = await this.findStoriesBySlugs(variantSlugs);
    const storyUuids: string[] = [];

    for (const [slug, story] of storiesMap) {
        if (story?.uuid) {
            storyUuids.push(story.uuid.toString()); // Storyblok uses UUIDs for references
        }
    }

    return storyUuids;
}

// Example: Transform variant data with relationships
private async transformVariantData(
    variant: ProductVariant,
    defaultLanguageCode: LanguageCode,
    variantSlug: string,
    collections?: Collection[],
) {
    const translation = variant.translations.find(
        t => t.languageCode === defaultLanguageCode
    );
    if (!translation) return undefined;

    // Find parent product and collection references using the same batch lookup patterns
    const parentProductStoryUuid = await this.findParentProductStoryUuid(variant, defaultLanguageCode);
    const collectionStoryUuids = await this.findCollectionStoryUuids(collections, defaultLanguageCode);

    return {
        story: {
            name: translation.name,
            slug: variantSlug,
            content: {
                component: COMPONENT_TYPE.product_variant,
                vendureId: variant.id.toString(),
                parentProduct: parentProductStoryUuid ? [parentProductStoryUuid] : [],
                collections: collectionStoryUuids,
            },
        },
        publish: 1,
    };
}

// Additional relationship methods like findParentProductStoryUuid and findCollectionStoryUuids
// follow similar patterns and are available in the working example repository.
```

### CRUD Operations

These methods handle the basic Create, Read, Update, and Delete operations for stories in Storyblok. They follow REST API conventions and leverage the centralized request method for consistent behavior.

```ts
// Create a new story in Storyblok
private async createStoryFromProduct(product, defaultLanguageCode) {
    // Transform Vendure product data into Storyblok story format
    const data = this.transformProductData(product, defaultLanguageCode);

    // POST to the stories endpoint to create a new story
    return this.makeStoryblokRequest({
        method: 'POST',
        endpoint: 'stories',
        data,
    });
}

// Find an existing story by its slug
private async findStoryBySlug(slug: string) {
    // Use Storyblok's by_slugs query parameter for efficient lookup
    const response = await this.makeStoryblokRequest({
        method: 'GET',
        endpoint: `stories?by_slugs=${slug}`,
    });

    // Return the matching story or undefined if not found
    return response.stories.find((story: any) => story.slug === slug);
}

// Additional CRUD methods like updateStoryFromProduct and deleteStoryFromProduct
// follow similar patterns with PUT and DELETE HTTP methods respectively.
// Full implementations are available in the working example repository.

```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  cmsApiKey: process.env.STORYBLOK_API_KEY,
  storyblokSpaceId: process.env.STORYBLOK_SPACE_ID,
}),
```

This setup provides a complete Storyblok CMS integration that automatically creates the necessary content types and syncs your Vendure catalog with structured content in Storyblok.

</TabItem>
<TabItem value="strapi" label="Strapi">

**Strapi CMS Integration**

:::tip Working Example
The complete, production-ready Strapi implementation can be found in the [Strapi integration example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/strapi-cms-integration). It includes advanced features like plugin-based content types, batch operations, and relationship management.
:::

This guide provides a complete integration for Vendure with Strapi CMS, including setting up a Strapi application with a custom plugin and implementing the synchronization service.

**Setting up Strapi**

#### 1. Create a new Strapi project

Initialize your Strapi project using the CLI:

```bash
npx create-strapi-app@latest strapi-integration-app
cd strapi-integration-app
```

Choose the following options when prompted:

- Installation type: **Custom (manual settings)**
- Database client: **Sqlite** (or your preferred database)
- Use TypeScript: **Yes**

#### 2. Create a Vendure Integration Plugin

Generate a custom plugin to organize Vendure content types:

```bash
npm run strapi generate plugin
# Plugin name: vendure-integration-plugin
```

#### 3. Configure Environment Variables

Add these variables to your `.env` file:

```env
STRAPI_API_TOKEN=your_api_token
STRAPI_BASE_URL=http://localhost:1337
```

**Defining Content Types**

#### 1. Create Vendure-specific content types

Create the content type schemas in your plugin's `server/content-types` folder:

**vendure-product/schema.json**

```json title="src/plugins/vendure-integration-plugin/server/content-types/vendure-product/schema.json"
{
    "kind": "collectionType",
    "collectionName": "vendure_products",
    "info": {
        "displayName": "Vendure Product",
        "singularName": "vendure-product",
        "pluralName": "vendure-products"
    },
    "attributes": {
        "vendureId": {
            "type": "integer",
            "required": true,
            "unique": true
        },
        "name": {
            "type": "string",
            "required": true
        },
        "slug": {
            "type": "string",
            "required": true,
            "unique": true
        },
        "productVariants": {
            "type": "relation",
            "relation": "oneToMany",
            "target": "api::vendure-product-variant.vendure-product-variant",
            "mappedBy": "product"
        }
    }
}
```

**Additional content types for VendureProductVariant and VendureCollection**
follow the same pattern with appropriate field definitions and relationships.

```json
// vendure-product-variant/schema.json
// vendure-collection/schema.json
```

#### 2. Enable the plugin

Update your Strapi configuration to enable the plugin:

```ts title="config/plugins.ts"
export default {
    'vendure-integration-plugin': {
        enabled: true,
        resolve: './src/plugins/vendure-integration-plugin',
    },
};
```

#### 3. Generate API tokens

After starting Strapi, create an API token:

1. Navigate to **Settings → API Tokens** in the Strapi admin panel
2. Create a new token with **Full access** or custom permissions
3. Save the token for use in your Vendure plugin configuration

**The Strapi Service**

The `StrapiService` handles all Strapi-specific operations including API communication, content management, and relationship resolution. Key features include:

- **Content Management**: CRUD operations using Strapi's REST API
- **Relationship Handling**: Manages references between products, variants, and collections
- **Batch Operations**: Efficient bulk lookups for related entities
- **Rate Limiting**: Configurable delays to prevent API overload

```ts title="src/plugins/cms/services/strapi.service.ts"
@Injectable()
export class StrapiService {
    private readonly strapiBaseUrl = 'http://localhost:1337/api';

    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    async syncProduct({ product, defaultLanguageCode, operationType }) {
        switch (operationType) {
            case 'create':
                return this.createDocumentFromProduct(product, defaultLanguageCode);
            case 'update':
                return this.updateDocumentFromProduct(product, defaultLanguageCode);
            case 'delete':
                return this.deleteDocumentFromProduct(product, defaultLanguageCode);
        }
    }

    private async makeStrapiRequest({ method, endpoint, data }) {
        await this.enforceRateLimit();
        const url = `${this.strapiBaseUrl}/${endpoint}`;

        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
        };

        if (this.options.strapiApiKey) {
            headers.Authorization = `Bearer ${this.options.strapiApiKey}`;
        }

        const response = await fetch(url, {
            method,
            headers,
            body: data ? JSON.stringify(data) : undefined,
        });

        if (!response.ok) {
            throw new Error(`Strapi API error: ${response.status}`);
        }
        return response.json();
    }

    private async findDocumentBySlug(collectionSlug: string, slug: string) {
        const endpoint = `${collectionSlug}?filters[slug][$eq]=${encodeURIComponent(slug)}&pagination[limit]=1`;
        const response = await this.makeStrapiRequest({
            method: 'GET',
            endpoint,
        });
        return response.data?.[0] || null;
    }

    private transformProductData(product, defaultLanguageCode: LanguageCode) {
        return {
            vendureId: product.id,
            name: product.translations[defaultLanguageCode]?.name,
            slug: product.translations[defaultLanguageCode]?.slug,
            // Additional fields and variant references
        };
    }

    // Additional methods: batch lookups, relationship management,
    // variant and collection sync operations, etc.
}
```

**Configuration**

Update your plugin configuration to include Strapi options:

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    // ... existing options
    strapiApiKey?: string;
    strapiBaseUrl?: string;
}
```

**Environment Variables**

Add these to your `.env` file:

```env
STRAPI_API_KEY=your_strapi_api_token
STRAPI_BASE_URL=http://localhost:1337
```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  strapiApiKey: process.env.STRAPI_API_KEY,
  strapiBaseUrl: process.env.STRAPI_BASE_URL || 'http://localhost:1337',
}),
```

This setup provides a complete Strapi CMS integration that automatically syncs your Vendure catalog with Strapi's flexible content management system, leveraging Strapi's plugin architecture for organized content types.

</TabItem>
<TabItem value="Sanity" title="Sanity">
**Sanity CMS Integration**
:::tip Working Example
The complete, production-ready Sanity implementation can be found in the [Sanity integration example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/sanity-cms-integration). It includes advanced features like rate limiting, content type management, and bulk operations.
:::

This tab provides a complete guide for integrating Vendure with Sanity CMS, including setting up a Sanity Studio and implementing the synchronization service.

**Setting up Sanity Studio**

#### 1. Create a new Studio with Sanity CLI

Initialize your Sanity project using the CLI. Replace `<project-id>` with your actual project ID:

```bash
npm create sanity@latest -- --project <project-id> --dataset production --template clean --typescript --output-path studio-vendure-plugin
cd studio-vendure-plugin
```

#### 2. Run Sanity Studio locally

Start the development server:

```bash
npm run dev
```

#### 3. Log in to the Studio

Open your browser to `http://localhost:3333` and log in using the same service (Google, GitHub, or email) that you used with the Sanity CLI.

**Defining Schema Types**

#### 1. Create Vendure-specific document types

Create the Vendure-specific schema files in your `schemaTypes` folder:

For example, here is a schema file for a Vendure product variant:

**vendureProductVariant.ts**

```ts
import { defineField, defineType } from 'sanity';

export const vendureProductVariant = defineType({
    name: 'vendureProductVariant',
    title: 'Vendure Product Variant',
    type: 'document',
    fields: [
        defineField({
            name: 'vendureId',
            type: 'number',
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'title',
            type: 'string',
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'slug',
            type: 'slug',
            options: { source: 'title' },
            validation: rule => rule.required(),
        }),
        defineField({
            name: 'vendureProduct',
            type: 'reference',
            to: [{ type: 'vendureProduct' }],
        }),
        defineField({
            name: 'vendureCollections',
            type: 'array',
            of: [{ type: 'reference', to: [{ type: 'vendureCollection' }] }],
        }),
    ],
});
```

#### 2. Register the schema types

Update your `schemaTypes/index.ts` file:

```ts
import { vendureCollection } from './vendureCollection';
import { vendureProductType } from './vendureProductType';
import { vendureProductVariant } from './vendureProductVariant';

export const schemaTypes = [
    vendureProductVariant,
    // ...
];
```

**The Sanity Service**

The `SanityService` handles all Sanity-specific operations including document management, GROQ queries, and API communication. Key features include:

- **Document Management**: CRUD operations using Sanity's mutation API
- **GROQ Queries**: Efficient document lookups and relationship resolution
- **Reference Handling**: Manages document references between products, variants, and collections
- **Schema Independence**: Works with schemas defined in Sanity Studio

```ts title="src/plugins/cms/services/sanity.service.ts"
@Injectable()
export class SanityService {
    private get sanityBaseUrl(): string {
        return `https://${this.options.sanityProjectId}.api.sanity.io/v2025-09-01`;
    }

    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    async syncProduct({ product, defaultLanguageCode, operationType }) {
        switch (operationType) {
            case 'create':
                return this.createDocumentFromProduct(product, defaultLanguageCode);
            case 'update':
                return this.updateDocumentFromProduct(product, defaultLanguageCode);
            case 'delete':
                return this.deleteDocumentFromProduct(product, defaultLanguageCode);
        }
    }

    private async makeSanityRequest({ method, endpoint, data }) {
        const url = `${this.sanityBaseUrl}/${endpoint}`;

        const response = await fetch(url, {
            method,
            headers: {
                Authorization: `Bearer ${this.options.sanityApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        });

        if (!response.ok) {
            throw new Error(`Sanity API error: ${response.status}`);
        }
        return response.json();
    }

    private transformProductData(product, defaultLanguageCode: LanguageCode) {
        return {
            _type: 'vendureProduct',
            vendureId: parseInt(product.id.toString()),
            title: product.translations[defaultLanguageCode]?.name,
            slug: { current: product.translations[defaultLanguageCode]?.slug },
            // Additional fields and variant references
        };
    }

    // Additional methods: GROQ queries, document lookups,
    // batch operations, relationship management, etc.
}
```

**Configuration**

Update your plugin configuration to include Sanity options:

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    // ... existing options
    sanityApiKey?: string;
    sanityProjectId?: string;
    sanityDataset?: string;
}
```

**Environment Variables**

Add these to your `.env` file:

```env
SANITY_API_KEY=your_sanity_api_key
SANITY_PROJECT_ID=your_project_id
SANITY_DATASET=production
```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  sanityApiKey: process.env.SANITY_API_KEY,
  sanityProjectId: process.env.SANITY_PROJECT_ID,
  sanityDataset: process.env.SANITY_DATASET,
}),
```

This setup provides a complete Sanity CMS integration that automatically syncs your Vendure catalog with structured content in Sanity Studio.

</TabItem>
<TabItem value="payload" label="Payload">

:::tip Working Example
The complete, production-ready Payload implementation can be found in the [Payload integration example](https://github.com/vendure-ecommerce/examples/tree/publish/examples/payload-cms-integration). It includes advanced features like local API communication, collection management, and relationship handling.
:::

This guide provides a complete integration for Vendure with Payload CMS, including setting up a Payload application and implementing the synchronization service.

**Setting up Payload CMS**

#### 1. Create a new Payload project

Initialize your Payload project using the CLI:

```bash
npx create-payload-app@latest payload-integration-app
cd payload-integration-app
```

Choose the following options when prompted:

- Use TypeScript? **Yes**
- Choose a database: **PostgreSQL** (or your preferred database)
- Package manager: **pnpm**

#### 2. Configure development server

Update your development script to use port 3001 to avoid conflicts with Vendure:

```json title="package.json"
{
    "scripts": {
        "dev": "cross-env PAYLOAD_CONFIG_PATH=src/payload.config.ts nodemon --exec tsx src/server.ts",
        "dev:payload": "payload dev --port 3001"
    }
}
```

**Defining Collection Schemas**

#### 1. Create Vendure-specific collections

Create the collection configurations in your `collections` folder:

**VendureEntities.ts**

```ts title="src/collections/VendureEntities.ts"
import type { CollectionConfig } from 'payload/types';

export const VendureProduct: CollectionConfig = {
    slug: 'vendure-product',
    // WARNING: Development-only access! This grants unrestricted CRUD access to anyone.
    // For production, implement proper authentication and role-based access control.
    access: {
        // DEV ONLY: Public read access
        read: () => true,
        create: () => true,
        update: () => true,
        delete: () => true,
    },
    fields: [
        {
            name: 'id',
            type: 'number',
            required: true,
            unique: true,
        },
        {
            name: 'name',
            type: 'text',
            required: true,
        },
        {
            name: 'slug',
            type: 'text',
            required: true,
        },
        {
            name: 'productVariants',
            type: 'relationship',
            relationTo: 'vendure-product-variant',
            hasMany: true,
        },
    ],
};

// Additional collection configurations for VendureProductVariant and VendureCollection
// follow the same pattern with appropriate field definitions and relationships.

// export const VendureProductVariant: CollectionConfig = { ... }
// export const VendureCollection: CollectionConfig = { ... }
```

#### 2. Register collections in Payload config

Update your `payload.config.ts` to include the Vendure collections:

```ts title="src/payload.config.ts"
import { VendureProduct, VendureProductVariant, VendureCollection } from './collections/VendureEntities';

export default buildConfig({
    // ... other config
    collections: [
        VendureProduct,
        VendureProductVariant,
        VendureCollection,
        // ... other collections
    ],
});
```

#### 3. Run migrations

After setting up your collections, create and run migrations:

```bash
# Create a fresh migration (drops all tables and recreates)
pnpm payload migrate:fresh

# Alternative: Create specific migration (safer for production)
pnpm payload migrate:create add-vendure-collections
pnpm payload migrate

# Generate TypeScript types
pnpm payload generate:types
```

**The Payload Service**

The `PayloadService` handles all Payload-specific operations including local API communication, document management, and relationship resolution. Key features include:

- **Local API Communication**: Direct communication with Payload's local API
- **Document Management**: CRUD operations for Payload documents
- **Relationship Handling**: Manages references between products, variants, and collections
- **Rate Limiting**: Implements delays to prevent API overload

```ts title="src/plugins/cms/services/payload.service.ts"
@Injectable()
export class PayloadService {
    private readonly payloadBaseUrl = 'http://localhost:3001/api';

    constructor(@Inject(CMS_PLUGIN_OPTIONS) private options: PluginInitOptions) {}

    async syncProduct({ product, defaultLanguageCode, operationType }) {
        switch (operationType) {
            case 'create':
                return this.createDocumentFromProduct(product, defaultLanguageCode);
            case 'update':
                return this.updateDocumentFromProduct(product, defaultLanguageCode);
            case 'delete':
                return this.deleteDocumentFromProduct(product);
        }
    }

    private async makePayloadRequest({ method, endpoint, data }) {
        await this.enforceRateLimit();
        const url = `${this.payloadBaseUrl}/${endpoint}`;

        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
        };

        if (this.options.payloadApiKey) {
            headers.Authorization = `Bearer ${this.options.payloadApiKey}`;
        }

        const response = await fetch(url, {
            method,
            headers,
            body: data ? JSON.stringify(data) : undefined,
        });

        if (!response.ok) {
            throw new Error(`Payload API error: ${response.status}`);
        }
        return response.json();
    }

    private async createDocumentFromProduct(product, defaultLanguageCode: LanguageCode) {
        const existingDocument = await this.findDocumentBySlug(
            'vendure-product',
            product.translations[defaultLanguageCode]?.slug,
        );

        if (existingDocument) {
            return this.updateDocumentFromProduct(product, defaultLanguageCode);
        }

        const data = this.transformProductData(product, defaultLanguageCode);
        return this.makePayloadRequest({
            method: 'POST',
            endpoint: 'vendure-product',
            data,
        });
    }

    private transformProductData(product, defaultLanguageCode: LanguageCode) {
        return {
            id: parseInt(product.id.toString()),
            name: product.translations[defaultLanguageCode]?.name,
            slug: product.translations[defaultLanguageCode]?.slug,
        };
    }

    private async findDocumentBySlug(collection: string, slug: string) {
        const response = await this.makePayloadRequest({
            method: 'GET',
            endpoint: `${collection}?where[slug][equals]=${slug}`,
        });
        return response.docs?.[0];
    }

    private async enforceRateLimit() {
        // Implement 100ms delay to prevent API overload
        await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Additional methods: syncVariant, syncCollection, relationship management, etc.
}
```

**Configuration**

Update your plugin configuration to include Payload options:

```ts title="src/plugins/cms/types.ts"
export interface PluginInitOptions {
    // ... existing options
    payloadApiKey?: string;
    payloadBaseUrl?: string;
}
```

**Environment Variables**

Add these to your `.env` file:

```env
PAYLOAD_API_KEY=your_payload_api_key
PAYLOAD_BASE_URL=http://localhost:3001/api
```

**Final Plugin Configuration**

```ts title="src/vendure-config.ts"
CmsPlugin.init({
  payloadApiKey: process.env.PAYLOAD_API_KEY,
  payloadBaseUrl: process.env.PAYLOAD_BASE_URL || 'http://localhost:3001/api',
}),
```

This setup provides a complete Payload CMS integration that automatically syncs your Vendure catalog with Payload's flexible content management system, supporting local development and production deployments.

</TabItem>
<TabItem value="more-soon" label="More guides coming soon">
:::info
More CMS integration guides coming soon! Have a specific CMS you'd like to see covered? [Let us know](https://github.com/vendure-ecommerce/vendure/discussions).
:::
</TabItem>
</Tabs>

## Admin UI Integration

To allow for manual synchronization, we can extend the Admin API with new mutations. Let's use the CLI to generate the API extensions:

```bash
# Generate API extensions for the CMS plugin
npx vendure add -a CmsSyncAdminResolver --selected-plugin CmsPlugin
```

### Extending the GraphQL API

```ts title="src/plugins/cms/api/api-extensions.ts"
export const adminApiExtensions = gql`
  extend type Mutation {
    syncProductToCms(productId: ID!): SyncResponse!
    syncCollectionToCms(collectionId: ID!): SyncResponse!
  }
  // ...
`;
```

### Implementing the Resolver

The resolver for these mutations re-uses the existing `CmsSyncService` to add a job to the queue.

```ts title="src/plugins/cms/api/cms-sync-admin.resolver.ts"
@Resolver()
export class CmsSyncAdminResolver {
    constructor(private cmsSyncService: CmsSyncService) {}

    @Mutation()
    @Allow(Permission.UpdateCatalog)
    async syncProductToCms(@Args() args: { productId: ID }): Promise<any> {
        const syncData = { entityId: args.productId, operationType: 'update' };
        return this.cmsSyncService.syncProductToCms(syncData);
    }
}
```

## Final Configuration

Finally, add the plugin to your `vendure-config.ts` file with the appropriate configuration for your chosen CMS platform.

```ts title="src/vendure-config.ts"
import { VendureConfig } from '@vendure/core';
import { CmsPlugin } from './plugins/cms/cms.plugin';

export const config: VendureConfig = {
    // ... other config
    plugins: [
        // ... other plugins
        CmsPlugin.init({
            // Configure based on your chosen CMS platform
            // See platform-specific tabs above for exact configuration
            cmsApiKey: process.env.CMS_API_KEY,
            // Additional CMS-specific options...
        }),
    ],
};
```

Refer to the platform-specific configuration examples in the tabs above for the exact environment variables and options needed for your chosen CMS.

For complete, production-ready implementations, see the working examples:

- [Storyblok CMS Integration](https://github.com/vendure-ecommerce/examples/tree/publish/examples/storyblok-cms-integration)
- [Strapi CMS Integration](https://github.com/vendure-ecommerce/examples/tree/publish/examples/strapi-cms-integration)
- [Sanity CMS Integration](https://github.com/vendure-ecommerce/examples/tree/publish/examples/sanity-cms-integration)
- [Payload CMS Integration](https://github.com/vendure-ecommerce/examples/tree/publish/examples/payload-cms-integration)
