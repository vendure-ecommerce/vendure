---
title: "API Keys"
---

Since v3.5.0

API keys provide non-interactive, role‑scoped access to Vendure’s APIs without a username/password. A key is bound to a specific User and inherits that User’s Roles & Channel permissions. Keys are stored securely (hash only) and can be rotated and revoked.

## Configuration

API keys support header-based authentication only. Configure the generation strategy if you need a custom key format. Header auth is active only when the `ApiKeyAuthenticationStrategy` is registered for that API and the corresponding scope is enabled:

```ts
import { VendureConfig, DefaultApiKeyGenerationStrategy, NativeAuthenticationStrategy, ApiKeyAuthenticationStrategy } from '@vendure/core';

export const config: VendureConfig = {
  // ...
  authOptions: {
    apiKey: {
      generationStrategy: new DefaultApiKeyGenerationStrategy(), // optional
      admin: { enabled: true, sessionDuration: '8h' },
      shop: { enabled: false, sessionDuration: '2h' },
    },
    adminAuthenticationStrategy: [new NativeAuthenticationStrategy(), new ApiKeyAuthenticationStrategy()],
    shopAuthenticationStrategy: [new NativeAuthenticationStrategy()],
  },
};
```

Notes:
- Keys are generated by `DefaultApiKeyGenerationStrategy` (32‑byte base64url, `vk_` prefix) by default. Supply your own `generationStrategy` to change format.
- Session duration: By default, API‑key sessions use the API key's remaining lifetime (capped to `expiresAt`). You can override the base duration per API via `apiKey.admin.sessionDuration` / `apiKey.shop.sessionDuration`.

## Header auth

Use header-based authentication with an API key. When a valid key is provided, Vendure creates a normal authenticated session (stored in the DB) and returns the session token according to your `tokenMethod` configuration.

Send the API key directly in the `Authorization` header using the `ApiKey` scheme:

```bash
curl \
  -H "Authorization: ApiKey vk_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ me { id identifier } }"}' \
  http://localhost:3000/admin-api
```

Characteristics:

- A persisted authenticated session is created on first header-authenticated request and its token is set on the response (cookie and/or header per `tokenMethod`).
- Subsequent requests may use the session token or continue using the API key header.
- The request inherits the bound User’s Roles & Channel permissions.
- Admin requests require Admin-scoped keys; Shop requests require Shop-scoped keys.

### Examples

- Admin only header auth (default):

```ts
import { VendureConfig, NativeAuthenticationStrategy, ApiKeyAuthenticationStrategy, DefaultApiKeyGenerationStrategy } from '@vendure/core';

export const config: VendureConfig = {
  authOptions: {
    apiKey: {
      generationStrategy: new DefaultApiKeyGenerationStrategy(),
      admin: { enabled: true },   // default
      shop: { enabled: false },   // default
    },
    adminAuthenticationStrategy: [
      new NativeAuthenticationStrategy(),
      new ApiKeyAuthenticationStrategy(),
    ],
    shopAuthenticationStrategy: [new NativeAuthenticationStrategy()],
  },
};
```

```bash
curl \
  -H "Authorization: ApiKey vk_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" \
  -H "vendure-token-method: cookie" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ me { id identifier } }"}' \
  http://localhost:3000/admin-api
```

- Enable Shop header auth and override per-scope session durations:

```ts
export const config: VendureConfig = {
  authOptions: {
    apiKey: {
      generationStrategy: new DefaultApiKeyGenerationStrategy(),
      admin: { enabled: true, sessionDuration: '12h' },
      shop: { enabled: true, sessionDuration: '2h' },
    },
    adminAuthenticationStrategy: [new NativeAuthenticationStrategy(), new ApiKeyAuthenticationStrategy()],
    shopAuthenticationStrategy: [new NativeAuthenticationStrategy(), new ApiKeyAuthenticationStrategy()],
  },
};
```

```bash
curl \
  -H "Authorization: ApiKey vk_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ activeOrder { id } }"}' \
  http://localhost:3000/shop-api
```

- Strategy-based authenticate mutation (optional):

```graphql
mutation AuthWithApiKey($key: String!) {
  authenticate(input: { apiKey: { key: $key } }) {
    __typename
    ... on CurrentUser {
      id
      identifier
    }
    ... on InvalidCredentialsError { errorCode message }
    ... on NotVerifiedError { errorCode message }
  }
}
```

### Shop API keys

Shop API requests also support header-based API keys:

```bash
curl \
  -H "Authorization: ApiKey vk_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ activeOrder { id } }"}' \
  http://localhost:3000/shop-api
```

Notes:
- Owner and permission checks still apply based on the User’s roles.

## Managing keys

GraphQL operations are self‑scoped in the Admin API:

- `createApiKey(name, expiresAt, notes?)` → creates a key for the current user; returns `ApiKeyWithSecret` with the raw key (shown once). An expiration date is required.
- `apiKeys(options?)` → lists the current user’s keys (pagination/filtering).
- `rotateApiKey(id)` → rotates and returns the new raw key.
- `revokeApiKey(id)` → revokes an active key.
- `invalidateApiKeySessions(id)` → invalidates sessions minted from the key.
- `deleteApiKey(id)` → permanently deletes a key and invalidates sessions minted from it.

Examples:

```graphql
mutation CreateKey($name: String!, $expires: DateTime!, $notes: String) {
  createApiKey(name: $name, expiresAt: $expires, notes: $notes) {
    apiKey { id name expiresAt status }
    rawKey
  }
}

mutation RotateKey($id: ID!) {
  rotateApiKey(id: $id) { apiKey { id name expiresAt status } rawKey }
}

mutation RevokeKey($id: ID!) {
  revokeApiKey(id: $id) { id name status revokedAt }
}

mutation InvalidateSessions($id: ID!) {
  invalidateApiKeySessions(id: $id)
}

mutation DeleteKey($id: ID!) {
  deleteApiKey(id: $id) { result message }
}
```

Recommended practices:
- Prefer rotation over long-lived keys. E.g. rotate on a schedule and at signs of compromise.
- Use `expiresAt` for automatic expiry where feasible.
- Store the raw key in your secret manager at creation/rotation time; you cannot retrieve it later.

## Security guidelines

- Hashing: Only a hash of the key is stored in the database; raw keys are never persisted.
- Logging: Do not log raw keys. Ensure app and infra logs don’t capture Authorization headers.
- Least privilege: Keys inherit the bound User’s Roles & Channels. Create dedicated administrator/users for automation with minimal roles and restricted channel access.
- TTL: By default, sessions minted from API keys are capped to the key’s `expiresAt`. Prefer shorter expirations and rotate keys regularly. Optionally override per API via `apiKey.admin.sessionDuration` / `apiKey.shop.sessionDuration`.
- Transport: Enforce HTTPS and HSTS. Never use API keys over plain HTTP.
- Token handling: Use `tokenMethod: 'cookie'` with `httpOnly`, `sameSite`, and `secure` in production, or restrict bearer-token exposure (CORS `Access-Control-Expose-Headers`).
- Rotation and revocation: Rotate keys periodically and on any suspicion. `rotateApiKey` returns a new raw key; `revokeApiKey` plus `invalidateApiKeySessions` cuts off live sessions.
- Monitoring: Track `lastUsedAt` for anomalies. Alert on unexpected usage patterns (IP, time, frequency).
- Network controls: Consider IP allowlists at the edge (reverse proxy, firewall) for automation users.
- API surface: Disable unused scopes (Shop or Admin) via `apiKey.*.enabled`. Disable GraphQL introspection in production if appropriate and restrict playground access.

## Dashboard UI

- A dedicated “API Keys” page is available from the user menu. It lists your keys, lets you create a key with presets (7/30/60/90/180 days, custom date), shows the computed expiry, and supports rotate/revoke/invalidate. The raw key is shown once with a Copy button.

## Permissions

- API key management is self‑scoped and requires only that the user is authenticated.
