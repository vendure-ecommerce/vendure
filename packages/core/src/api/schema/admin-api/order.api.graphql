type Query {
    order(id: ID!): Order
    orders(options: OrderListOptions): OrderList!
}

type Mutation {
    settlePayment(id: ID!): SettlePaymentResult!
    addFulfillmentToOrder(input: FulfillOrderInput!): AddFulfillmentToOrderResult!
    cancelOrder(input: CancelOrderInput!): CancelOrderResult!
    refundOrder(input: RefundOrderInput!): RefundOrderResult!
    settleRefund(input: SettleRefundInput!): SettleRefundResult!
    addNoteToOrder(input: AddNoteToOrderInput!): Order!
    updateOrderNote(input: UpdateOrderNoteInput!): HistoryEntry!
    deleteOrderNote(id: ID!): DeletionResponse!
    transitionOrderToState(id: ID!, state: String!): TransitionOrderToStateResult
    transitionFulfillmentToState(id: ID!, state: String!): TransitionFulfillmentToStateResult!
    transitionPaymentToState(id: ID!, state: String!): TransitionPaymentToStateResult!
    setOrderCustomFields(input: UpdateOrderInput!): Order
}

type Order {
    nextStates: [String!]!
}

# generated by generateListOptions function
input OrderListOptions

# Populated with any custom fields at run-time
input UpdateOrderInput {
    id: ID!
}

input FulfillOrderInput {
    lines: [OrderLineInput!]!
    method: String!
    trackingCode: String
}

input CancelOrderInput {
    "The id of the order to be cancelled"
    orderId: ID!
    "Optionally specify which OrderLines to cancel. If not provided, all OrderLines will be cancelled"
    lines: [OrderLineInput!]
    reason: String
}

input RefundOrderInput {
    lines: [OrderLineInput!]!
    shipping: Int!
    adjustment: Int!
    paymentId: ID!
    reason: String
}

input OrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input SettleRefundInput {
    id: ID!
    transactionId: String!
}

input AddNoteToOrderInput {
    id: ID!
    note: String!
    isPublic: Boolean!
}

input UpdateOrderNoteInput {
    noteId: ID!
    note: String
    isPublic: Boolean
}

"Returned if the Payment settlement fails"
type SettlePaymentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    paymentErrorMessage: String!
}

"Returned if no OrderLines have been specified for the operation"
type EmptyOrderLineSelectionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if the specified items are already part of a Fulfillment"
type ItemsAlreadyFulfilledError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned if attempting to create a Fulfillment when there is insufficient
stockOnHand of a ProductVariant to satisfy the requested quantity.
"""
type InsufficientStockOnHandError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    productVariantId: ID!
    productVariantName: String!
    stockOnHand: Int!
}

"Returned if an operation has specified OrderLines from multiple Orders"
type MultipleOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to cancel lines from an Order which is still active"
type CancelActiveOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund a Payment against OrderLines from a different Order"
type PaymentOrderMismatchError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an Order which is not in the expected state"
type RefundOrderStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund an Order but neither items nor shipping refund was specified"
type NothingToRefundError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an OrderItem which has already been refunded"
type AlreadyRefundedError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    refundId: ID!
}

"Returned if the specified quantity of an OrderLine is greater than the number of items in that line"
type QuantityTooGreatError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned when there is an error in transitioning the Refund state"
type RefundStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Payment state"
type PaymentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Fulfillment state"
type FulfillmentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

union TransitionOrderToStateResult = Order | OrderStateTransitionError
union SettlePaymentResult =
      Payment
    | SettlePaymentError
    | PaymentStateTransitionError
    | OrderStateTransitionError
union AddFulfillmentToOrderResult =
      Fulfillment
    | EmptyOrderLineSelectionError
    | ItemsAlreadyFulfilledError
    | InsufficientStockOnHandError
union CancelOrderResult =
      Order
    | EmptyOrderLineSelectionError
    | QuantityTooGreatError
    | MultipleOrderError
    | CancelActiveOrderError
    | OrderStateTransitionError
union RefundOrderResult =
      Refund
    | QuantityTooGreatError
    | NothingToRefundError
    | OrderStateTransitionError
    | MultipleOrderError
    | PaymentOrderMismatchError
    | RefundOrderStateError
    | AlreadyRefundedError
    | RefundStateTransitionError
union SettleRefundResult = Refund | RefundStateTransitionError
union TransitionFulfillmentToStateResult = Fulfillment | FulfillmentStateTransitionError
union TransitionPaymentToStateResult = Payment | PaymentStateTransitionError
