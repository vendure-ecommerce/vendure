type Query {
    order(id: ID!): Order
    orders(options: OrderListOptions): OrderList!
    "Returns a list of eligible shipping methods for the draft Order"
    eligibleShippingMethodsForDraftOrder(orderId: ID!): [ShippingMethodQuote!]!
}

type Mutation {
    settlePayment(id: ID!): SettlePaymentResult!
    cancelPayment(id: ID!): CancelPaymentResult!
    addFulfillmentToOrder(input: FulfillOrderInput!): AddFulfillmentToOrderResult!
    cancelOrder(input: CancelOrderInput!): CancelOrderResult!
    refundOrder(input: RefundOrderInput!): RefundOrderResult!
    settleRefund(input: SettleRefundInput!): SettleRefundResult!
    addNoteToOrder(input: AddNoteToOrderInput!): Order!
    updateOrderNote(input: UpdateOrderNoteInput!): HistoryEntry!
    deleteOrderNote(id: ID!): DeletionResponse!
    transitionOrderToState(id: ID!, state: String!): TransitionOrderToStateResult
    transitionFulfillmentToState(id: ID!, state: String!): TransitionFulfillmentToStateResult!
    transitionPaymentToState(id: ID!, state: String!): TransitionPaymentToStateResult!
    setOrderCustomFields(input: UpdateOrderInput!): Order
    """
    Allows a different Customer to be assigned to an Order. Added in v2.2.0.
    """
    setOrderCustomer(input: SetOrderCustomerInput!): Order
    """
    Allows an Order to be modified after it has been completed by the Customer. The Order must first
    be in the `Modifying` state.
    """
    modifyOrder(input: ModifyOrderInput!): ModifyOrderResult!
    """
    Used to manually create a new Payment against an Order.
    This can be used by an Administrator when an Order is in the ArrangingPayment state.

    It is also used when a completed Order
    has been modified (using `modifyOrder`) and the price has increased. The extra payment
    can then be manually arranged by the administrator, and the details used to create a new
    Payment.
    """
    addManualPaymentToOrder(input: ManualPaymentInput!): AddManualPaymentToOrderResult!
    "Creates a draft Order"
    createDraftOrder: Order!
    "Deletes a draft Order"
    deleteDraftOrder(orderId: ID!): DeletionResponse!
    "Adds an item to the draft Order."
    addItemToDraftOrder(orderId: ID!, input: AddItemToDraftOrderInput!): UpdateOrderItemsResult!
    "Adjusts a draft OrderLine. If custom fields are defined on the OrderLine entity, a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available."
    adjustDraftOrderLine(orderId: ID!, input: AdjustDraftOrderLineInput!): UpdateOrderItemsResult!
    "Remove an OrderLine from the draft Order"
    removeDraftOrderLine(orderId: ID!, orderLineId: ID!): RemoveOrderItemsResult!
    setCustomerForDraftOrder(
        orderId: ID!
        customerId: ID
        input: CreateCustomerInput
    ): SetCustomerForDraftOrderResult!
    "Sets the shipping address for a draft Order"
    setDraftOrderShippingAddress(orderId: ID!, input: CreateAddressInput!): Order!
    "Sets the billing address for a draft Order"
    setDraftOrderBillingAddress(orderId: ID!, input: CreateAddressInput!): Order!
    "Allows any custom fields to be set for the active order"
    setDraftOrderCustomFields(orderId: ID!, input: UpdateOrderInput!): Order!
    "Applies the given coupon code to the draft Order"
    applyCouponCodeToDraftOrder(orderId: ID!, couponCode: String!): ApplyCouponCodeResult!
    "Removes the given coupon code from the draft Order"
    removeCouponCodeFromDraftOrder(orderId: ID!, couponCode: String!): Order
    "Sets the shipping method by id, which can be obtained with the `eligibleShippingMethodsForDraftOrder` query"
    setDraftOrderShippingMethod(orderId: ID!, shippingMethodId: ID!): SetOrderShippingMethodResult!
}

type Order {
    nextStates: [String!]!
}

input OrderFilterParameter {
    customerLastName: StringOperators
    transactionId: StringOperators
}

input OrderSortParameter {
    customerLastName: SortOrder
    transactionId: SortOrder
}

# generated by generateListOptions function
input OrderListOptions

input SetOrderCustomerInput {
    orderId: ID!
    customerId: ID!
    note: String
}

# Populated with any custom fields at run-time
input UpdateOrderInput {
    id: ID!
}

input FulfillOrderInput {
    lines: [OrderLineInput!]!
    handler: ConfigurableOperationInput!
}

input CancelOrderInput {
    "The id of the order to be cancelled"
    orderId: ID!
    "Optionally specify which OrderLines to cancel. If not provided, all OrderLines will be cancelled"
    lines: [OrderLineInput!]
    "Specify whether the shipping charges should also be cancelled. Defaults to false"
    cancelShipping: Boolean
    reason: String
}

input RefundOrderInput {
    lines: [OrderLineInput!]!
    shipping: Money!
    adjustment: Money!
    """
    If an amount is specified, this value will be used to create a Refund rather than calculating the
    amount automatically. This was added in v2.2 and will be the preferred way to specify the refund
    amount in the future. The `lines`, `shipping` and `adjustment` fields will likely be removed in a future
    version.
    """
    amount: Money
    paymentId: ID!
    reason: String
}

input OrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input SettleRefundInput {
    id: ID!
    transactionId: String!
}

input AddNoteToOrderInput {
    id: ID!
    note: String!
    isPublic: Boolean!
}

input UpdateOrderNoteInput {
    noteId: ID!
    note: String
    isPublic: Boolean
}

input AdministratorPaymentInput {
    paymentMethod: String
    metadata: JSON
}

input AdministratorRefundInput {
    paymentId: ID!
    reason: String
    """
    The amount to be refunded to this particular Payment. This was introduced in
    v2.2.0 as the preferred way to specify the refund amount. The `lines`, `shipping` and `adjustment`
    fields will be removed in a future version.
    """
    amount: Money
}

input ModifyOrderOptions {
    freezePromotions: Boolean
    recalculateShipping: Boolean
}

input UpdateOrderAddressInput {
    fullName: String
    company: String
    streetLine1: String
    streetLine2: String
    city: String
    province: String
    postalCode: String
    countryCode: String
    phoneNumber: String
}

input ModifyOrderInput {
    dryRun: Boolean!
    orderId: ID!
    addItems: [AddItemInput!]
    adjustOrderLines: [OrderLineInput!]
    surcharges: [SurchargeInput!]
    updateShippingAddress: UpdateOrderAddressInput
    updateBillingAddress: UpdateOrderAddressInput
    note: String
    """
    Deprecated in v2.2.0. Use `refunds` instead to allow multiple refunds to be
    applied in the case that multiple payment methods have been used on the order.
    """
    refund: AdministratorRefundInput
    refunds: [AdministratorRefundInput!]
    options: ModifyOrderOptions
    couponCodes: [String!]
    """
    Added in v2.2
    """
    shippingMethodIds: [ID!]
}

input AddItemInput {
    productVariantId: ID!
    quantity: Int!
}

input OrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input SurchargeInput {
    description: String!
    sku: String
    price: Money!
    priceIncludesTax: Boolean!
    taxRate: Float
    taxDescription: String
}

input ManualPaymentInput {
    orderId: ID!
    method: String!
    transactionId: String
    metadata: JSON
}

input AddItemToDraftOrderInput {
    productVariantId: ID!
    quantity: Int!
}

input AdjustDraftOrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

"Returned if the Payment settlement fails"
type SettlePaymentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    paymentErrorMessage: String!
}

"Returned if the Payment cancellation fails"
type CancelPaymentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    paymentErrorMessage: String!
}

"Returned if no OrderLines have been specified for the operation"
type EmptyOrderLineSelectionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if the specified items are already part of a Fulfillment"
type ItemsAlreadyFulfilledError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if the specified FulfillmentHandler code is not valid"
type InvalidFulfillmentHandlerError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an error is thrown in a FulfillmentHandler's createFulfillment method"
type CreateFulfillmentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    fulfillmentHandlerError: String!
}

"""
Returned if attempting to create a Fulfillment when there is insufficient
stockOnHand of a ProductVariant to satisfy the requested quantity.
"""
type InsufficientStockOnHandError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    productVariantId: ID!
    productVariantName: String!
    stockOnHand: Int!
}

"Returned if an operation has specified OrderLines from multiple Orders"
type MultipleOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to cancel lines from an Order which is still active"
type CancelActiveOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund a Payment against OrderLines from a different Order"
type PaymentOrderMismatchError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an Order which is not in the expected state"
type RefundOrderStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund an Order but neither items nor shipping refund was specified"
type NothingToRefundError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an OrderItem which has already been refunded"
type AlreadyRefundedError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    refundId: ID!
}

"Returned if the specified quantity of an OrderLine is greater than the number of items in that line"
type QuantityTooGreatError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if `amount` is greater than the maximum un-refunded amount of the Payment"
type RefundAmountError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    maximumRefundable: Int!
}

"Returned when there is an error in transitioning the Refund state"
type RefundStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Payment state"
type PaymentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Fulfillment state"
type FulfillmentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when attempting to modify the contents of an Order that is not in the `Modifying` state."
type OrderModificationStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned when a call to modifyOrder fails to specify any changes"
type NoChangesSpecifiedError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to modifyOrder fails to include a paymentMethod even
though the price has increased as a result of the changes.
"""
type PaymentMethodMissingError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to modifyOrder fails to include a refundPaymentId even
though the price has decreased as a result of the changes.
"""
type RefundPaymentIdMissingError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to addManualPaymentToOrder is made but the Order
is not in the required state.
"""
type ManualPaymentStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

union TransitionOrderToStateResult = Order | OrderStateTransitionError
union SettlePaymentResult =
      Payment
    | SettlePaymentError
    | PaymentStateTransitionError
    | OrderStateTransitionError
union CancelPaymentResult = Payment | CancelPaymentError | PaymentStateTransitionError
union AddFulfillmentToOrderResult =
      Fulfillment
    | EmptyOrderLineSelectionError
    | ItemsAlreadyFulfilledError
    | InsufficientStockOnHandError
    | InvalidFulfillmentHandlerError
    | FulfillmentStateTransitionError
    | CreateFulfillmentError
union CancelOrderResult =
      Order
    | EmptyOrderLineSelectionError
    | QuantityTooGreatError
    | MultipleOrderError
    | CancelActiveOrderError
    | OrderStateTransitionError
union RefundOrderResult =
      Refund
    | QuantityTooGreatError
    | NothingToRefundError
    | OrderStateTransitionError
    | MultipleOrderError
    | PaymentOrderMismatchError
    | RefundOrderStateError
    | AlreadyRefundedError
    | RefundStateTransitionError
    | RefundAmountError
union SettleRefundResult = Refund | RefundStateTransitionError
union TransitionFulfillmentToStateResult = Fulfillment | FulfillmentStateTransitionError
union TransitionPaymentToStateResult = Payment | PaymentStateTransitionError
union ModifyOrderResult =
      Order
    | NoChangesSpecifiedError
    | OrderModificationStateError
    | PaymentMethodMissingError
    | RefundPaymentIdMissingError
    | OrderLimitError
    | NegativeQuantityError
    | InsufficientStockError
    | CouponCodeExpiredError
    | CouponCodeInvalidError
    | CouponCodeLimitError
    | IneligibleShippingMethodError
union AddManualPaymentToOrderResult = Order | ManualPaymentStateError
union SetCustomerForDraftOrderResult = Order | EmailAddressConflictError
