type Query {
    order(id: ID!): Order
    orders(options: OrderListOptions): OrderList!
}

type Mutation {
    settlePayment(id: ID!): SettlePaymentResult!
    addFulfillmentToOrder(input: FulfillOrderInput!): AddFulfillmentToOrderResult!
    cancelOrder(input: CancelOrderInput!): CancelOrderResult!
    refundOrder(input: RefundOrderInput!): RefundOrderResult!
    settleRefund(input: SettleRefundInput!): SettleRefundResult!
    addNoteToOrder(input: AddNoteToOrderInput!): Order!
    updateOrderNote(input: UpdateOrderNoteInput!): HistoryEntry!
    deleteOrderNote(id: ID!): DeletionResponse!
    transitionOrderToState(id: ID!, state: String!): TransitionOrderToStateResult
    transitionFulfillmentToState(id: ID!, state: String!): TransitionFulfillmentToStateResult!
    transitionPaymentToState(id: ID!, state: String!): TransitionPaymentToStateResult!
    setOrderCustomFields(input: UpdateOrderInput!): Order
    """
    Allows an Order to be modified after it has been completed by the Customer. The Order must first
    be in the `Modifying` state.
    """
    modifyOrder(input: ModifyOrderInput!): ModifyOrderResult!
    """
    Used to manually create a new Payment against an Order. This is used when a completed Order
    has been modified (using `modifyOrder`) and the price has increased. The extra payment
    can then be manually arranged by the administrator, and the details used to create a new
    Payment.
    """
    addManualPaymentToOrder(input: ManualPaymentInput!): AddManualPaymentToOrderResult!
}

type Order {
    nextStates: [String!]!
}

input OrderFilterParameter {
    customerLastName: StringOperators
}

input OrderSortParameter {
    customerLastName: SortOrder
}

# generated by generateListOptions function
input OrderListOptions

# Populated with any custom fields at run-time
input UpdateOrderInput {
    id: ID!
}

input FulfillOrderInput {
    lines: [OrderLineInput!]!
    handler: ConfigurableOperationInput!
}

input CancelOrderInput {
    "The id of the order to be cancelled"
    orderId: ID!
    "Optionally specify which OrderLines to cancel. If not provided, all OrderLines will be cancelled"
    lines: [OrderLineInput!]
    reason: String
}

input RefundOrderInput {
    lines: [OrderLineInput!]!
    shipping: Int!
    adjustment: Int!
    paymentId: ID!
    reason: String
}

input OrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input SettleRefundInput {
    id: ID!
    transactionId: String!
}

input AddNoteToOrderInput {
    id: ID!
    note: String!
    isPublic: Boolean!
}

input UpdateOrderNoteInput {
    noteId: ID!
    note: String
    isPublic: Boolean
}

input AdministratorPaymentInput {
    paymentMethod: String
    metadata: JSON
}

input AdministratorRefundInput {
    paymentId: ID!
    reason: String
}

input ModifyOrderOptions {
    freezePromotions: Boolean
    recalculateShipping: Boolean
}

input UpdateOrderAddressInput {
    fullName: String
    company: String
    streetLine1: String
    streetLine2: String
    city: String
    province: String
    postalCode: String
    countryCode: String
    phoneNumber: String
}

input ModifyOrderInput {
    dryRun: Boolean!
    orderId: ID!
    addItems: [AddItemInput!]
    adjustOrderLines: [AdjustOrderLineInput!]
    surcharges: [SurchargeInput!]
    updateShippingAddress: UpdateOrderAddressInput
    updateBillingAddress: UpdateOrderAddressInput
    note: String
    refund: AdministratorRefundInput
    options: ModifyOrderOptions
}

input AddItemInput {
    productVariantId: ID!
    quantity: Int!
}

input AdjustOrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input OrderLineInput {
    orderLineId: ID!
    quantity: Int!
}

input SurchargeInput {
    description: String!
    sku: String
    price: Int!
    priceIncludesTax: Boolean!
    taxRate: Float
    taxDescription: String
}

input ManualPaymentInput {
    orderId: ID!
    method: String!
    transactionId: String
    metadata: JSON
}

"Returned if the Payment settlement fails"
type SettlePaymentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    paymentErrorMessage: String!
}

"Returned if no OrderLines have been specified for the operation"
type EmptyOrderLineSelectionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if the specified items are already part of a Fulfillment"
type ItemsAlreadyFulfilledError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if the specified FulfillmentHandler code is not valid"
type InvalidFulfillmentHandlerError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an error is thrown in a FulfillmentHandler's createFulfillment method"
type CreateFulfillmentError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    fulfillmentHandlerError: String!
}

"""
Returned if attempting to create a Fulfillment when there is insufficient
stockOnHand of a ProductVariant to satisfy the requested quantity.
"""
type InsufficientStockOnHandError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    productVariantId: ID!
    productVariantName: String!
    stockOnHand: Int!
}

"Returned if an operation has specified OrderLines from multiple Orders"
type MultipleOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to cancel lines from an Order which is still active"
type CancelActiveOrderError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund a Payment against OrderLines from a different Order"
type PaymentOrderMismatchError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an Order which is not in the expected state"
type RefundOrderStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    orderState: String!
}

"Returned if an attempting to refund an Order but neither items nor shipping refund was specified"
type NothingToRefundError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned if an attempting to refund an OrderItem which has already been refunded"
type AlreadyRefundedError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    refundId: ID!
}

"Returned if the specified quantity of an OrderLine is greater than the number of items in that line"
type QuantityTooGreatError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned when there is an error in transitioning the Refund state"
type RefundStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Payment state"
type PaymentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when there is an error in transitioning the Fulfillment state"
type FulfillmentStateTransitionError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
    transitionError: String!
    fromState: String!
    toState: String!
}

"Returned when attempting to modify the contents of an Order that is not in the `Modifying` state."
type OrderModificationStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"Returned when a call to modifyOrder fails to specify any changes"
type NoChangesSpecifiedError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to modifyOrder fails to include a paymentMethod even
though the price has increased as a result of the changes.
"""
type PaymentMethodMissingError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to modifyOrder fails to include a refundPaymentId even
though the price has decreased as a result of the changes.
"""
type RefundPaymentIdMissingError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

"""
Returned when a call to addManualPaymentToOrder is made but the Order
is not in the required state.
"""
type ManualPaymentStateError implements ErrorResult {
    errorCode: ErrorCode!
    message: String!
}

union TransitionOrderToStateResult = Order | OrderStateTransitionError
union SettlePaymentResult =
      Payment
    | SettlePaymentError
    | PaymentStateTransitionError
    | OrderStateTransitionError
union AddFulfillmentToOrderResult =
      Fulfillment
    | EmptyOrderLineSelectionError
    | ItemsAlreadyFulfilledError
    | InsufficientStockOnHandError
    | InvalidFulfillmentHandlerError
    | FulfillmentStateTransitionError
    | CreateFulfillmentError
union CancelOrderResult =
      Order
    | EmptyOrderLineSelectionError
    | QuantityTooGreatError
    | MultipleOrderError
    | CancelActiveOrderError
    | OrderStateTransitionError
union RefundOrderResult =
      Refund
    | QuantityTooGreatError
    | NothingToRefundError
    | OrderStateTransitionError
    | MultipleOrderError
    | PaymentOrderMismatchError
    | RefundOrderStateError
    | AlreadyRefundedError
    | RefundStateTransitionError
union SettleRefundResult = Refund | RefundStateTransitionError
union TransitionFulfillmentToStateResult = Fulfillment | FulfillmentStateTransitionError
union TransitionPaymentToStateResult = Payment | PaymentStateTransitionError
union ModifyOrderResult =
      Order
    | NoChangesSpecifiedError
    | OrderModificationStateError
    | PaymentMethodMissingError
    | RefundPaymentIdMissingError
    | OrderLimitError
    | NegativeQuantityError
    | InsufficientStockError
union AddManualPaymentToOrderResult = Order | ManualPaymentStateError
