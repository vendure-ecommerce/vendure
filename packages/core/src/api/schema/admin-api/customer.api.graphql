type Query {
  customers(options: CustomerListOptions): CustomerList!
  customer(id: ID!): Customer
}

type Mutation {
  "Create a new Customer. If a password is provided, a new User will also be created an linked to the Customer."
  createCustomer(input: CreateCustomerInput!, password: String): CreateCustomerResult!

  "Update an existing Customer"
  updateCustomer(input: UpdateCustomerInput!): UpdateCustomerResult!

  "Delete a Customer"
  deleteCustomer(id: ID!): DeletionResponse!

  "Create a new Address and associate it with the Customer specified by customerId"
  createCustomerAddress(customerId: ID!, input: CreateAddressInput!): Address!

  "Update an existing Address"
  updateCustomerAddress(input: UpdateAddressInput!): Address!

  "Update an existing Address"
  deleteCustomerAddress(id: ID!): Success!

  addNoteToCustomer(input: AddNoteToCustomerInput!): Customer!
  updateCustomerNote(input: UpdateCustomerNoteInput!): HistoryEntry!
  deleteCustomerNote(id: ID!): DeletionResponse!
}

type Customer implements Node {
  groups: [CustomerGroup!]!
  history(options: HistoryEntryListOptions): HistoryEntryList!
}

input UpdateCustomerInput {
  id: ID!
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  emailAddress: String
}

# generated by generateListOptions function
input CustomerListOptions

input AddNoteToCustomerInput {
  id: ID!
  note: String!
  isPublic: Boolean!
}

input UpdateCustomerNoteInput {
  noteId: ID!
  note: String!
}

union CreateCustomerResult = Customer | EmailAddressConflictError
union UpdateCustomerResult = Customer | EmailAddressConflictError
